#include "Memory.h"

BOOL Memory::Scan(LPINT* luaState, const wchar_t* module, const char* pattern, UINT pLength)
{
    MODULEINFO moduleInfo;

    if (K32GetModuleInformation(GetCurrentProcess(), GetModuleHandleW(module), &moduleInfo, sizeof(moduleInfo)))
    {
        IMAGE_DOS_HEADER DosHeader = *reinterpret_cast<IMAGE_DOS_HEADER*>(moduleInfo.lpBaseOfDll);

        IMAGE_NT_HEADERS NtHeader = *reinterpret_cast<IMAGE_NT_HEADERS*>((DWORD)moduleInfo.lpBaseOfDll + DosHeader.e_lfanew);

        IMAGE_OPTIONAL_HEADER OptHeader = NtHeader.OptionalHeader;

        moduleInfo.lpBaseOfDll = (LPVOID)((DWORD)moduleInfo.lpBaseOfDll + OptHeader.BaseOfCode);

        MEMORY_BASIC_INFORMATION MBI = { 0 };
        SYSTEM_INFO SI = { 0 };
        GetSystemInfo(&SI);
        DWORD Start = (DWORD)moduleInfo.lpBaseOfDll;
        DWORD End = (DWORD)SI.lpMaximumApplicationAddress;
        do
        {
            while (VirtualQuery((LPVOID)Start, &MBI, sizeof(MBI))) {
                if ((MBI.Protect & PAGE_READWRITE)
                    && !(MBI.Protect & PAGE_GUARD))
                {
                    for (DWORD i = (DWORD)(MBI.BaseAddress); i - (DWORD)(MBI.BaseAddress) < MBI.RegionSize - pLength; ++i)
                    {
                        if (Compare((LPCH)i, pattern, pLength))
                        {
                            *luaState = (int*)i;
                            return TRUE;
                        }
                    }
                }
                Start += MBI.RegionSize;
            }
        } while (Start < End);
    }

    return FALSE;
}

int Memory::FindPattern(const wchar_t* module, const char* pattern, UINT pLength, int offset)
{
	MODULEINFO moduleInfo;

	if (K32GetModuleInformation(GetCurrentProcess(), GetModuleHandleW(module), &moduleInfo, sizeof(moduleInfo)))
	{
        IMAGE_DOS_HEADER DosHeader = *reinterpret_cast<IMAGE_DOS_HEADER*>(moduleInfo.lpBaseOfDll);

        IMAGE_NT_HEADERS NtHeader = *reinterpret_cast<IMAGE_NT_HEADERS*>((DWORD)moduleInfo.lpBaseOfDll + DosHeader.e_lfanew);

		IMAGE_OPTIONAL_HEADER OptHeader = NtHeader.OptionalHeader;

        moduleInfo.lpBaseOfDll = (LPVOID)((DWORD)moduleInfo.lpBaseOfDll + OptHeader.BaseOfCode);

        MEMORY_BASIC_INFORMATION memInfo;

        VirtualQuery(moduleInfo.lpBaseOfDll, &memInfo, sizeof(memInfo));

		char* begin = static_cast<char*>(moduleInfo.lpBaseOfDll);
		char* end = begin + memInfo.RegionSize - pLength;

		for (char* c = begin; c != end; c++)
		{
            if (Compare(c, pattern, pLength))
            {
                return (int)(c + offset);
            }
		}
	}

	return NULL;
}

BOOL Memory::Compare(LPCH address, const char* pattern, UINT pLength)
{
    LPCH begin = (LPCH)address;
    bool matched = true;
    auto it = begin;

    if (*(begin + pLength - 1) != pattern[pLength - 1])
        return FALSE;

    for (UINT i = 0; i < pLength; i++)
    {
        if (pattern[i] != '?' && *it != pattern[i]) {
            matched = false;
            break;
        }
        it++;
    }

    return matched;
}

DWORD Memory::unprotect(DWORD addr)
{
    if (addr == NULL)
        return NULL;

    BYTE* tAddr = (BYTE*)addr;

    /*  Calcualte the size of the function.

        In theory this will run until it hits the next
        functions prolog. It assumes all calls are aligned to
        16 bytes. (grazie katie)
    */
    do
    {
        tAddr += 16;
    } while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

    DWORD funcSz = tAddr - (BYTE*)addr;

    /* Allocate memory for the new function */
    PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (nFunc == NULL)
        return addr;

    /* Copy the function to the newly allocated memory */
    memcpy(nFunc, (void*)addr, funcSz);

    BYTE* pos = (BYTE*)nFunc;
    BOOL valid = false;
    do
    {
        /*  Check for the return check with the sig:
            72 ?? A1 ?? ?? ?? ?? 8B

            If the sig matches replace the the jb with a jmp.
        */
        if (pos[0] == 0x72 && pos[2] == 0xA1 && pos[7] == 0x8B) {
            *(BYTE*)pos = 0xEB;

            DWORD cByte = (DWORD)nFunc;
            do
            {
                /*  Check if the current byte is a call, if it is,
                    calculate the new relative call(s).

                    *(->E8 + 1) = originalFunction - nextInstruction

                    oFuncPos - Position of call in original function
                        = originalFunction + (->E8 - newFunction)

                    oFuncAddr - Original call location
                        = oFuncPos + rel32Offset + sizeof(call)

                    relativeAddr - New relative address
                        = oFuncAddr - ->E8 - sizeof(call)

                    Since we are not using a disassembler we assume
                    that if we hit a E8 byte which is properly aligned
                    it is a relative call.
                    For a small amount of compensation I skip the location
                    of the call, since it is possible to have the byte
                    E8 inside of it.
                */
                if (*(BYTE*)cByte == 0xE8)
                {
                    DWORD oFuncPos = addr + (cByte - (DWORD)nFunc);
                    DWORD oFuncAddr = (oFuncPos + *(DWORD*)(oFuncPos + 1)) + 5;

                    if (oFuncAddr % 16 == 0)
                    {
                        DWORD relativeAddr = oFuncAddr - cByte - 5;
                        *(DWORD*)(cByte + 1) = relativeAddr;

                        /* Don't check rel32 */
                        cByte += 4;
                    }
                }

                cByte += 1;
            } while (cByte - (DWORD)nFunc < funcSz);

            valid = true;
        }
        pos += 1;
    } while ((DWORD)pos < (DWORD)nFunc + funcSz);

    /* This function has no return check, let's not waste memory */
    if (!valid)
    {
        VirtualFree(nFunc, 0, MEM_RELEASE);
        return addr;
    }

    return (DWORD)nFunc;
}